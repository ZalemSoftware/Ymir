<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_66) on Mon Dec 05 11:48:38 BRST 2016 -->
<title>AndroidBugsUtils (ymir.client-android.commons 1.0.0 API)</title>
<meta name="date" content="2016-12-05">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="AndroidBugsUtils (ymir.client-android.commons 1.0.0 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../android/support/v4/app/EnhancedDialogFragment.html" title="class in android.support.v4.app"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?android/support/v4/app/AndroidBugsUtils.html" target="_top">Frames</a></li>
<li><a href="AndroidBugsUtils.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">android.support.v4.app</div>
<h2 title="Class AndroidBugsUtils" class="title">Class AndroidBugsUtils</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>android.support.v4.app.AndroidBugsUtils</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="typeNameLabel">AndroidBugsUtils</span>
extends java.lang.Object</pre>
<div class="block">Utilitário para aplicar contornos aos bugs do Android cujo as soluções ainda não foram liberadas em versões oficiais.<br>
 O objetivo desta classe é evitar que vários locais do código da aplicação tenham que ser alterados para contornar um bug.
 Desta forma, o contorno do bug se limita a apenas uma chamada de método. Assim, quando o bug for corrigido, será questão
 de apenas remover a chamada do método, sem nenhum outro impacto para o código.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForAlertDialogWithFlexibleListViewBug-android.app.Dialog-android.view.View-">applyWorkaroundForAlertDialogWithFlexibleListViewBug</a></span>(android.app.Dialog&nbsp;dialog,
                                                    android.view.View&nbsp;dialogView)</code>
<div class="block">Contorno para o problema em que um <code>Dialog</code> com um <code>ListView</code> com tamanho flexível (de acordo com o conteúdo)
 executa sucessivos layouts, fazendo com que haja uma demora para a exibição do Dialog.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForAlertDialogWithInvisibleTitleBug-Builder-">applyWorkaroundForAlertDialogWithInvisibleTitleBug</a></span>(Builder&nbsp;dialogBuilder)</code>
<div class="block">Contorno para o bug em que um <code>AlertDialog</code> que foi construído sem título não mostra o título que foi setado posteriormente (através
 do <code>AlertDialog#setTitle(CharSequence)</code>.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.ArrayList&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForArrayListDefaultClassloaderBug-android.os.Parcel-">applyWorkaroundForArrayListDefaultClassloaderBug</a></span>(android.os.Parcel&nbsp;source)</code>
<div class="block">Aplica a mesma correção do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForParcelableDefaultClassloaderBug-android.os.Parcel-"><code>applyWorkaroundForParcelableDefaultClassloaderBug(android.os.Parcel)</code></a> mas
 lê um <code>ArrayList</code> do <code>Parcel</code> que pode conter <code>Parcelable</code> em seu conteúdo.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug163954-java.lang.IllegalArgumentException-">applyWorkaroundForBug163954</a></span>(java.lang.IllegalArgumentException&nbsp;e)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=163954 <br>
 O SwipeRefreshLayout se perde em um evento de click misterioso (sem ação do usuário).</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug17423-DialogFragment-">applyWorkaroundForBug17423</a></span>(DialogFragment&nbsp;dialogFragment)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=17423
 <br>
 O <code>DialogFragment</code> com <code>retainInstance</code> == <code>true</code> não exibe o Dialog ao ser restaurado
 (devido a alteração de orientação, por exemplo) porque fica com a mensagem de <code>dismiss</code> pendente.<br>
 A correção é definir a mensagem de <code>dismiss</code> como <code>null</code> quando a View do fragmento é destruído.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static PagerAdapter</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug27526-ViewPager-PagerAdapter-OnPageChangeListener-">applyWorkaroundForBug27526</a></span>(ViewPager&nbsp;pager,
                          PagerAdapter&nbsp;adapter,
                          OnPageChangeListener&nbsp;listener)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=27526
 <br>
 O <code>android.support.v4.view.ViewPager</code> não chamada o método <code>android.support.v4.view.ViewPager.OnPageChangeListener#onPageSelected(int)</code> na primeira vez em que
 ele é utilizado.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static android.app.DatePickerDialog</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug34833-android.content.Context-android.app.DatePickerDialog.OnDateSetListener-int-int-int-">applyWorkaroundForBug34833</a></span>(android.content.Context&nbsp;context,
                          android.app.DatePickerDialog.OnDateSetListener&nbsp;callBack,
                          int&nbsp;year,
                          int&nbsp;monthOfYear,
                          int&nbsp;dayOfMonth)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=34833
 <br>
 A classe <code>DatePickerDialog</code> sempre chama o callback <code>DatePickerDialog.OnDateSetListener</code> em seu <code>onStop</code>,
 fazendo com que o callback seja chamado duas vezes quando a seleção de data é confirmada e chamando também quando
 a seleção é cancelada.<br>
 O contorno extende a classe DatePickerDialog e faz com que o callback seja chamado apenas na situação correta.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static android.app.TimePickerDialog</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug34833-android.content.Context-android.app.TimePickerDialog.OnTimeSetListener-int-int-boolean-">applyWorkaroundForBug34833</a></span>(android.content.Context&nbsp;context,
                          android.app.TimePickerDialog.OnTimeSetListener&nbsp;callBack,
                          int&nbsp;hourOfDay,
                          int&nbsp;minute,
                          boolean&nbsp;is24Hour)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=34833
 <br>
 A classe <code>TimePickerDialog</code> sempre chama o callback <code>TimePickerDialog.OnTimeSetListener</code> em seu <code>onStop</code>,
 fazendo com que o callback seja chamado duas vezes quando a seleção de data é confirmada e chamando também quando
 a seleção é cancelada.<br>
 O contorno extende a classe TimePickerDialog e faz com que o callback seja chamado apenas na situação correta.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug37484-SavedState-android.content.Context-">applyWorkaroundForBug37484</a></span>(SavedState&nbsp;savedState,
                          android.content.Context&nbsp;context)</code>
<div class="block">Contorno para o bug: https://code.google.com/p/android/issues/detail?id=37484
 <br>
 O <code>Bundle</code> do SavedState não fica com o ClassLoader certo depois de ser restaurado de uma activity que foi destruída,
 ocasionando em um BadParcelableException -> ClassNotFoundException.<br>
 O contorno é setar o ClassLoader correto no SavedState.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Stack&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug3847-android.os.Bundle-java.lang.String-">applyWorkaroundForBug3847</a></span>(android.os.Bundle&nbsp;bundle,
                         java.lang.String&nbsp;key)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=3847
 <br>
 Quando um objeto cujo a classe implementa <code>List</code> é salvo em um <code>Bundle</code> durante a destruição de uma
 Activity, ele restaura este objeto posteriormente sempre como um <code>ArrayList</code>, igorando a classe original do
 objeto.<br>
 A correção obtém o objeto salvo como Collection e adiciona o conteúdo na classe correta.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug52962-android.content.Context-">applyWorkaroundForBug52962</a></span>(android.content.Context&nbsp;context)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=52962 <br>
 O BuildConfig.DEBUG de bibliotecas fica sempre como <code>false</code>, mesmo que a aplicação tenha sido buildada em modo DEBUG.<br>
 O contorno obtém o BuildConfig.DEBUG da aplicação através de reflexão.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug5973_read-android.os.Parcel-">applyWorkaroundForBug5973_read</a></span>(android.os.Parcel&nbsp;parcel)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=5973
 A classe <code>Parcel</code> não possui método para ler um <code>boolean</code>.<br>
 A correção lê um byte no lugar do boolean que deve ter sido escrito através do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug5973_write-android.os.Parcel-boolean-"><code>applyWorkaroundForBug5973_write(android.os.Parcel, boolean)</code></a>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug5973_write-android.os.Parcel-boolean-">applyWorkaroundForBug5973_write</a></span>(android.os.Parcel&nbsp;parcel,
                               boolean&nbsp;b)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=5973
 A classe <code>Parcel</code> não possui método para escrever um <code>boolean</code>.<br>
 A correção escreve um byte no lugar do boolean que depois deve ser lido através do método: <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug5973_read-android.os.Parcel-"><code>applyWorkaroundForBug5973_read(android.os.Parcel)</code></a>.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug69711-DrawerLayout-ActionBarDrawerToggle-android.view.View-">applyWorkaroundForBug69711</a></span>(DrawerLayout&nbsp;drawerLayout,
                          ActionBarDrawerToggle&nbsp;actionBarToggle,
                          android.view.View&nbsp;drawerView)</code>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=69711<br>
 O <code>drawerLayout</code> não chama o listener (<code>actionBarToggle</code>) quando é aberto antes de sofrer layout.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug74222_onRestoreInstanceState-Fragment-android.os.Bundle-">applyWorkaroundForBug74222_onRestoreInstanceState</a></span>(Fragment&nbsp;parent,
                                                 android.os.Bundle&nbsp;savedInstanceState)</code>
<div class="block">Contorno para o bug: https://code.google.com/p/android/issues/detail?id=74222
 <br>
 Fragmentos aninhados (filhos de outros fragmentos) com <code>retainInstance</code> == <code>true</code>
 não retém a instancia, passando pelo processo normal de destruíção e recuperação como um fragmento normal.<br>
 Esta parte do contorno restaura as instâncias dos fragmentos aninhados que foram armazenadas através do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug74222_onSaveInstanceState-Fragment-"><code>applyWorkaroundForBug74222_onSaveInstanceState(Fragment)</code></a>.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug74222_onSaveInstanceState-Fragment-">applyWorkaroundForBug74222_onSaveInstanceState</a></span>(Fragment&nbsp;parent)</code>
<div class="block">Contorno para o bug: https://code.google.com/p/android/issues/detail?id=74222
 <br>
 Fragmentos aninhados (filhos de outros fragmentos) com <code>retainInstance</code> == <code>true</code>
 não retém a instancia, passando pelo processo normal de destruíção e recuperação como um fragmento normal.<br>
 Esta parte do contorno armazena as instâncias dos fragmentos aninhados que devem ser retidos para utilizá-los mais tarde no momento em que eles
 forem recuperados, através do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug74222_onRestoreInstanceState-Fragment-android.os.Bundle-"><code>applyWorkaroundForBug74222_onRestoreInstanceState(Fragment, Bundle)</code></a>.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForDeadOptionsMenuBug-Fragment-">applyWorkaroundForDeadOptionsMenuBug</a></span>(Fragment&nbsp;fragment)</code>
<div class="block">Contorno para o bug em que o Android não invalida o options menu (action bar) quando um fragmento na seguinte situação é removido:
 
        o fragmento não possui options menu (<code>android.support.v4.app.Fragment#hasOptionsMenu()</code>);
        o fragmento tem fragmentos filhos que possuem options menu.
 
 O resultado é que acabam ficando ações mortas dos menus provenientes dos filhos do fragmento que foi removido.<br>
 O contorno é declarar que o fragmento possui options menu.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static &lt;K,V&gt;&nbsp;java.util.HashMap&lt;K,V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForHashMapDefaultClassloaderBug-android.os.Parcel-">applyWorkaroundForHashMapDefaultClassloaderBug</a></span>(android.os.Parcel&nbsp;source)</code>
<div class="block">Aplica a mesma correção do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForParcelableDefaultClassloaderBug-android.os.Parcel-"><code>applyWorkaroundForParcelableDefaultClassloaderBug(android.os.Parcel)</code></a> mas
 lê um <code>HashMap</code> do <code>Parcel</code> que pode conter <code>Parcelable</code> em seu conteúdo.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static android.content.Intent</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForIntentDefaultClassloaderBug-android.os.Parcel-">applyWorkaroundForIntentDefaultClassloaderBug</a></span>(android.os.Parcel&nbsp;source)</code>
<div class="block">Contorno para o bug em que o <code>Intent</code> é recuperado de um <code>Parcel</code> mas acaba deixando seus <code>extras</code>
 (<code>Bundle</code>) sem o <code>ClassLoader</code> da aplicação.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static FragmentManager</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForInvalidFragmentManagerStateBug-Fragment-">applyWorkaroundForInvalidFragmentManagerStateBug</a></span>(Fragment&nbsp;owner)</code>
<div class="block">Contorno para o bug em que o <code>android.support.v4.app.FragmentManager</code> de um fragmento (<code>android.support.v4.app.Fragment#getChildFragmentManager()</code>)
 causa IllegalStateException ao ser obtido antes do fragmento ser atachado à Activity.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static &lt;T extends android.os.Parcelable&gt;<br>T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForParcelableDefaultClassloaderBug-android.os.Parcel-">applyWorkaroundForParcelableDefaultClassloaderBug</a></span>(android.os.Parcel&nbsp;source)</code>
<div class="block">Contorno para o bug em que o <code>ClassLoader</code> padrão utilizado pelo <code>Parcel</code> não contém as classes
 da própria aplicação ou de suas bibliotecas (contém apenas as classes do Android), ocasionando <code>ClassNotFoundException</code>
 ao tentar ler um <code>Parcelable</code> de uma classe da Aplicação.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static android.content.Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForSamsung5DatePickerBug-android.content.Context-">applyWorkaroundForSamsung5DatePickerBug</a></span>(android.content.Context&nbsp;context)</code>
<div class="block">Contorno para o problema em que dispositivos da Samsung com Android 5 geram erro ao utilizar o <code>DatePickerDialog</code> com Material Design.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForSearchViewIconVsLogoBug-android.app.Activity-">applyWorkaroundForSearchViewIconVsLogoBug</a></span>(android.app.Activity&nbsp;activity)</code>
<div class="block">Contorno para o bug descrito em: https://groups.google.com/forum/#!msg/android-developers/r4oJO3DPPis/HDU1yhdlUFgJ
 <br>
 O SearchView troca o logo da aplicação pelo ícone qunado está mostrando o campo de pesquisa.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static android.text.TextWatcher</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForSwipeSpanBug-android.content.Context-android.widget.TextView-android.text.TextWatcher-">applyWorkaroundForSwipeSpanBug</a></span>(android.content.Context&nbsp;context,
                              android.widget.TextView&nbsp;textView,
                              android.text.TextWatcher&nbsp;textWatcher)</code>
<div class="block">Contorno para o bug em que o texto concebido através de um teclado com swipe é repetido quando o texto do <code>TextView</code>
 é alterado através do <code>TextWatcher.afterTextChanged(android.text.Editable)</code>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="applyWorkaroundForBug37484-SavedState-android.content.Context-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug37484</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForBug37484(SavedState&nbsp;savedState,
                                              android.content.Context&nbsp;context)</pre>
<div class="block">Contorno para o bug: https://code.google.com/p/android/issues/detail?id=37484
 <br>
 O <code>Bundle</code> do SavedState não fica com o ClassLoader certo depois de ser restaurado de uma activity que foi destruída,
 ocasionando em um BadParcelableException -> ClassNotFoundException.<br>
 O contorno é setar o ClassLoader correto no SavedState.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>savedState</code> - SavedState que será ajeitado.</dd>
<dd><code>context</code> - contexto cujo o ClassLoader será colocado no SavedState.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug74222_onSaveInstanceState-Fragment-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug74222_onSaveInstanceState</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForBug74222_onSaveInstanceState(Fragment&nbsp;parent)</pre>
<div class="block">Contorno para o bug: https://code.google.com/p/android/issues/detail?id=74222
 <br>
 Fragmentos aninhados (filhos de outros fragmentos) com <code>retainInstance</code> == <code>true</code>
 não retém a instancia, passando pelo processo normal de destruíção e recuperação como um fragmento normal.<br>
 Esta parte do contorno armazena as instâncias dos fragmentos aninhados que devem ser retidos para utilizá-los mais tarde no momento em que eles
 forem recuperados, através do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug74222_onRestoreInstanceState-Fragment-android.os.Bundle-"><code>applyWorkaroundForBug74222_onRestoreInstanceState(Fragment, Bundle)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parent</code> - fragmento pai dos aninhados que podem ser retidos.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug74222_onRestoreInstanceState-Fragment-android.os.Bundle-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug74222_onRestoreInstanceState</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForBug74222_onRestoreInstanceState(Fragment&nbsp;parent,
                                                                     android.os.Bundle&nbsp;savedInstanceState)</pre>
<div class="block">Contorno para o bug: https://code.google.com/p/android/issues/detail?id=74222
 <br>
 Fragmentos aninhados (filhos de outros fragmentos) com <code>retainInstance</code> == <code>true</code>
 não retém a instancia, passando pelo processo normal de destruíção e recuperação como um fragmento normal.<br>
 Esta parte do contorno restaura as instâncias dos fragmentos aninhados que foram armazenadas através do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug74222_onSaveInstanceState-Fragment-"><code>applyWorkaroundForBug74222_onSaveInstanceState(Fragment)</code></a>.
 A restauração é feita através da alteração do estado salvo do <code>FragmentManager</code>, fazendo as instâncias dos fragmentos passarem
 pelas inicializações de fragmentos retidos e a recolocação dos valores perdidos quando foram destruídas erroneamente.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parent</code> - fragmento pai dos aninhados que podem ser retidos.</dd>
<dd><code>savedInstanceState</code> - estado salvo do fragmento pai.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForInvalidFragmentManagerStateBug-Fragment-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForInvalidFragmentManagerStateBug</h4>
<pre>public static&nbsp;FragmentManager&nbsp;applyWorkaroundForInvalidFragmentManagerStateBug(Fragment&nbsp;owner)</pre>
<div class="block">Contorno para o bug em que o <code>android.support.v4.app.FragmentManager</code> de um fragmento (<code>android.support.v4.app.Fragment#getChildFragmentManager()</code>)
 causa IllegalStateException ao ser obtido antes do fragmento ser atachado à Activity. Como não há nenhuma documentação
 informando que o FragmentoManager do fragmento só pode ser obtido depois disso, é considerado um bug.<br>
 O contorno é ter um FragmentManager que engloba o fragmento e só chama o <code>android.support.v4.app.Fragment#getChildFragmentManager()</code>
 quando necessário, ou seja, depois do fragmento já ser atachado.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>owner</code> - fragmento dono do FragmentManager.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForDeadOptionsMenuBug-Fragment-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForDeadOptionsMenuBug</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForDeadOptionsMenuBug(Fragment&nbsp;fragment)</pre>
<div class="block">Contorno para o bug em que o Android não invalida o options menu (action bar) quando um fragmento na seguinte situação é removido:
 <ul>
        <li>o fragmento não possui options menu (<code>android.support.v4.app.Fragment#hasOptionsMenu()</code>);</li>
        <li>o fragmento tem fragmentos filhos que possuem options menu.</li>
 </ul>
 O resultado é que acabam ficando ações mortas dos menus provenientes dos filhos do fragmento que foi removido.<br>
 O contorno é declarar que o fragmento possui options menu.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fragment</code> - fragmento que será corrigido.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForParcelableDefaultClassloaderBug-android.os.Parcel-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForParcelableDefaultClassloaderBug</h4>
<pre>public static&nbsp;&lt;T extends android.os.Parcelable&gt;&nbsp;T&nbsp;applyWorkaroundForParcelableDefaultClassloaderBug(android.os.Parcel&nbsp;source)</pre>
<div class="block">Contorno para o bug em que o <code>ClassLoader</code> padrão utilizado pelo <code>Parcel</code> não contém as classes
 da própria aplicação ou de suas bibliotecas (contém apenas as classes do Android), ocasionando <code>ClassNotFoundException</code>
 ao tentar ler um <code>Parcelable</code> de uma classe da Aplicação. Como a documentação do <code>Parcel.readParcelable(ClassLoader)</code>,
 por exemplo, não informa que o ClassLoader padrão é um limitado apenas as classes do Android, ele leva a crer
 que irá funcionar normalmente para carregar um Parcelable proveniente de uma classe da Aplicação. Por isto, o
 ClassNotFoundException é considerado um bug.<br>
 O contorno é ler o Parcelable passando um ClassLoader que contenha as classes da aplicação.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - parcel utilizado na obtenção do Parcelable.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>o Parcelable obtido.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForHashMapDefaultClassloaderBug-android.os.Parcel-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForHashMapDefaultClassloaderBug</h4>
<pre>public static&nbsp;&lt;K,V&gt;&nbsp;java.util.HashMap&lt;K,V&gt;&nbsp;applyWorkaroundForHashMapDefaultClassloaderBug(android.os.Parcel&nbsp;source)</pre>
<div class="block">Aplica a mesma correção do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForParcelableDefaultClassloaderBug-android.os.Parcel-"><code>applyWorkaroundForParcelableDefaultClassloaderBug(android.os.Parcel)</code></a> mas
 lê um <code>HashMap</code> do <code>Parcel</code> que pode conter <code>Parcelable</code> em seu conteúdo.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - parcel utilizado na obtenção do HashMap.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>o HashMap obtido.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForArrayListDefaultClassloaderBug-android.os.Parcel-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForArrayListDefaultClassloaderBug</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.ArrayList&lt;T&gt;&nbsp;applyWorkaroundForArrayListDefaultClassloaderBug(android.os.Parcel&nbsp;source)</pre>
<div class="block">Aplica a mesma correção do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForParcelableDefaultClassloaderBug-android.os.Parcel-"><code>applyWorkaroundForParcelableDefaultClassloaderBug(android.os.Parcel)</code></a> mas
 lê um <code>ArrayList</code> do <code>Parcel</code> que pode conter <code>Parcelable</code> em seu conteúdo.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - parcel utilizado na obtenção do ArrayList.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>o ArrayList obtido.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForIntentDefaultClassloaderBug-android.os.Parcel-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForIntentDefaultClassloaderBug</h4>
<pre>public static&nbsp;android.content.Intent&nbsp;applyWorkaroundForIntentDefaultClassloaderBug(android.os.Parcel&nbsp;source)</pre>
<div class="block">Contorno para o bug em que o <code>Intent</code> é recuperado de um <code>Parcel</code> mas acaba deixando seus <code>extras</code>
 (<code>Bundle</code>) sem o <code>ClassLoader</code> da aplicação. O correto seria o Intent instanciar um Bundle que já vem
 com o ClassLoader da aplicação definido (como na maioria de seus construtores) ou então utilizar o ClassLoader vindo
 do <code>Parcelable.ClassLoaderCreator.createFromParcel(android.os.Parcel, ClassLoader)</code>.
 O contorno lê o Intent do Parcel e define manualmente o ClassLoader da apliacção nos extras.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - Parcel utilizado na obtenção do Intent.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>o Intent obtido.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForSearchViewIconVsLogoBug-android.app.Activity-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForSearchViewIconVsLogoBug</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForSearchViewIconVsLogoBug(android.app.Activity&nbsp;activity)</pre>
<div class="block">Contorno para o bug descrito em: https://groups.google.com/forum/#!msg/android-developers/r4oJO3DPPis/HDU1yhdlUFgJ
 <br>
 O SearchView troca o logo da aplicação pelo ícone qunado está mostrando o campo de pesquisa.
 O contorno é setar o logo como ícone da ActionBar.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>activity</code> - activity que terá o logo ajeitado.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug27526-ViewPager-PagerAdapter-OnPageChangeListener-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug27526</h4>
<pre>public static&nbsp;PagerAdapter&nbsp;applyWorkaroundForBug27526(ViewPager&nbsp;pager,
                                                      PagerAdapter&nbsp;adapter,
                                                      OnPageChangeListener&nbsp;listener)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=27526
 <br>
 O <code>android.support.v4.view.ViewPager</code> não chamada o método <code>android.support.v4.view.ViewPager.OnPageChangeListener#onPageSelected(int)</code> na primeira vez em que
 ele é utilizado. Nas demais trocas de página funciona normalmente, então este contorno
 ajeita o <code>android.support.v4.view.PagerAdapter</code> que será utilizado para que ele faça a primeira chamada no momento devido.<br>
 O listener ainda deve ser adicionado no pager para que as demais chamadas sejam efetuadas.<br>
 <br>
 21/08/2014: Novos testes revelaram que quando o ViewPager está sendo recuperado (depois de sair e voltar de uma tela, por exemplo)
 ele até faz a primeira chamada do listener, mas apenas se a página não for 0. Ou seja, se for navegado a uma página diferente
 da 0, sair e voltar, ele acaba chamando corretamente. Isto acaba fazendo com que se chame o listener duas vezes ao usar o workaround.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>o adapter ajeitado.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug3847-android.os.Bundle-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug3847</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;java.util.Stack&lt;T&gt;&nbsp;applyWorkaroundForBug3847(android.os.Bundle&nbsp;bundle,
                                                               java.lang.String&nbsp;key)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=3847
 <br>
 Quando um objeto cujo a classe implementa <code>List</code> é salvo em um <code>Bundle</code> durante a destruição de uma
 Activity, ele restaura este objeto posteriormente sempre como um <code>ArrayList</code>, igorando a classe original do
 objeto.<br>
 A correção obtém o objeto salvo como Collection e adiciona o conteúdo na classe correta.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bundle</code> - bundle que contém o objeto salvo.</dd>
<dd><code>key</code> - chave para obter o objeto.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>o objeto corrigido.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug34833-android.content.Context-android.app.DatePickerDialog.OnDateSetListener-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug34833</h4>
<pre>public static&nbsp;android.app.DatePickerDialog&nbsp;applyWorkaroundForBug34833(android.content.Context&nbsp;context,
                                                                      android.app.DatePickerDialog.OnDateSetListener&nbsp;callBack,
                                                                      int&nbsp;year,
                                                                      int&nbsp;monthOfYear,
                                                                      int&nbsp;dayOfMonth)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=34833
 <br>
 A classe <code>DatePickerDialog</code> sempre chama o callback <code>DatePickerDialog.OnDateSetListener</code> em seu <code>onStop</code>,
 fazendo com que o callback seja chamado duas vezes quando a seleção de data é confirmada e chamando também quando
 a seleção é cancelada.<br>
 O contorno extende a classe DatePickerDialog e faz com que o callback seja chamado apenas na situação correta.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>context</code> - contexto.</dd>
<dd><code>callBack</code> - callback da seleção da data.</dd>
<dd><code>year</code> - ano que será mostrado inicialmente.</dd>
<dd><code>monthOfYear</code> - mês que será mostrado inicialmente.</dd>
<dd><code>dayOfMonth</code> - dia que será mostrado inicialmente.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>um DatePickerDialog com o contorno do bug.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug34833-android.content.Context-android.app.TimePickerDialog.OnTimeSetListener-int-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug34833</h4>
<pre>public static&nbsp;android.app.TimePickerDialog&nbsp;applyWorkaroundForBug34833(android.content.Context&nbsp;context,
                                                                      android.app.TimePickerDialog.OnTimeSetListener&nbsp;callBack,
                                                                      int&nbsp;hourOfDay,
                                                                      int&nbsp;minute,
                                                                      boolean&nbsp;is24Hour)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=34833
 <br>
 A classe <code>TimePickerDialog</code> sempre chama o callback <code>TimePickerDialog.OnTimeSetListener</code> em seu <code>onStop</code>,
 fazendo com que o callback seja chamado duas vezes quando a seleção de data é confirmada e chamando também quando
 a seleção é cancelada.<br>
 O contorno extende a classe TimePickerDialog e faz com que o callback seja chamado apenas na situação correta.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>context</code> - contexto.</dd>
<dd><code>callBack</code> - callback da seleção da data.</dd>
<dd><code>hourOfDay</code> - hora que será mostrada inicialmente.</dd>
<dd><code>minute</code> - minuto que será mostrado inicialmente.</dd>
<dd><code>is24Hour</code> - indica se o formato da hora é em 24.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>um TimePickerDialog com o contorno do bug.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug17423-DialogFragment-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug17423</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForBug17423(DialogFragment&nbsp;dialogFragment)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=17423
 <br>
 O <code>DialogFragment</code> com <code>retainInstance</code> == <code>true</code> não exibe o Dialog ao ser restaurado
 (devido a alteração de orientação, por exemplo) porque fica com a mensagem de <code>dismiss</code> pendente.<br>
 A correção é definir a mensagem de <code>dismiss</code> como <code>null</code> quando a View do fragmento é destruído.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dialogFragment</code> - fragmento.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForAlertDialogWithInvisibleTitleBug-Builder-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForAlertDialogWithInvisibleTitleBug</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForAlertDialogWithInvisibleTitleBug(Builder&nbsp;dialogBuilder)</pre>
<div class="block">Contorno para o bug em que um <code>AlertDialog</code> que foi construído sem título não mostra o título que foi setado posteriormente (através
 do <code>AlertDialog#setTitle(CharSequence)</code>. O problema acontece porque o AlertDialog esconde a View que exibe o título se este valor
 não for definido no momento de sua construção. Desta forma, se o título for definido posteriormente ele simplesmente não aparece.
 O correto seria a View ter sua visibilidade alterada no momento da definição do novo título.<br>
 O contorno faz com que seja definido um texto temporário como titulo, fazendo com que a View do titulo seja criada.<br>
 <br>
 Este contorno só deve ser utilizado se o titulo do AlertDialog for definido logo após sua criação.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dialogBuilder</code> - construtor de AlertDialog.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForAlertDialogWithFlexibleListViewBug-android.app.Dialog-android.view.View-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForAlertDialogWithFlexibleListViewBug</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForAlertDialogWithFlexibleListViewBug(android.app.Dialog&nbsp;dialog,
                                                                        android.view.View&nbsp;dialogView)</pre>
<div class="block">Contorno para o problema em que um <code>Dialog</code> com um <code>ListView</code> com tamanho flexível (de acordo com o conteúdo)
 executa sucessivos layouts, fazendo com que haja uma demora para a exibição do Dialog. A demora é causada pela recriação das Views
 do ListView, o que até seria compreensível se fosse feita apenas uma vez a mais, devido a necessidade do Dialog saber o tamanho de
 seu conteúdo. Entretanto, o layout é executado inúmeras vezes desnecessariamente.<br>
 O contorno faz com que o tamanho do Dialog seja fixado após o layout, evitando futuros layouts desnecessários. Entretanto, este contorno
 não resolve completamente o problema, apenas reduz o número de layouts quase pela metade.<br>
 <br>
 Mais informações sobre o problema e a origem do contorno podem ser vistas <a href="http://stackoverflow.com/questions/19326142/why-listview-expand-collapse-animation-appears-much-slower-in-dialogfragment-tha">aqui</a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dialog</code> - Dialog onde o contorno será aplicado.</dd>
<dd><code>dialogView</code> - View do Dialog.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForSamsung5DatePickerBug-android.content.Context-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForSamsung5DatePickerBug</h4>
<pre>public static&nbsp;android.content.Context&nbsp;applyWorkaroundForSamsung5DatePickerBug(android.content.Context&nbsp;context)</pre>
<div class="block">Contorno para o problema em que dispositivos da Samsung com Android 5 geram erro ao utilizar o <code>DatePickerDialog</code> com Material Design.
 O erro é proveniente da própria implementação do Android 5 feita pela Samsung, que tenta formatar uma String passando um valor do tipo
 errado.<br>
 <br>
 O contorno cria um ContextWrapper que trata a situação específica do erro, corrigindo a String com erro para o formato correto.
 Baseado no seguinte <a href="http://stackoverflow.com/questions/28618405/datepicker-crashes-on-my-device-when-clicked-with-personal-app/34853067#34853067">post</a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>context</code> - contexto que será wrappeado com a correção.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>um contexto com a correção.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug5973_write-android.os.Parcel-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug5973_write</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForBug5973_write(android.os.Parcel&nbsp;parcel,
                                                   boolean&nbsp;b)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=5973
 A classe <code>Parcel</code> não possui método para escrever um <code>boolean</code>.<br>
 A correção escreve um byte no lugar do boolean que depois deve ser lido através do método: <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug5973_read-android.os.Parcel-"><code>applyWorkaroundForBug5973_read(android.os.Parcel)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parcel</code> - parcel que terá o boolean escrito.</dd>
<dd><code>b</code> - boolean</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug5973_read-android.os.Parcel-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug5973_read</h4>
<pre>public static&nbsp;boolean&nbsp;applyWorkaroundForBug5973_read(android.os.Parcel&nbsp;parcel)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=5973
 A classe <code>Parcel</code> não possui método para ler um <code>boolean</code>.<br>
 A correção lê um byte no lugar do boolean que deve ter sido escrito através do método <a href="../../../../android/support/v4/app/AndroidBugsUtils.html#applyWorkaroundForBug5973_write-android.os.Parcel-boolean-"><code>applyWorkaroundForBug5973_write(android.os.Parcel, boolean)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parcel</code> - parcel que terá o boolean lido.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>o boolean lido do parcel.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForSwipeSpanBug-android.content.Context-android.widget.TextView-android.text.TextWatcher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForSwipeSpanBug</h4>
<pre>public static&nbsp;android.text.TextWatcher&nbsp;applyWorkaroundForSwipeSpanBug(android.content.Context&nbsp;context,
                                                                      android.widget.TextView&nbsp;textView,
                                                                      android.text.TextWatcher&nbsp;textWatcher)</pre>
<div class="block">Contorno para o bug em que o texto concebido através de um teclado com swipe é repetido quando o texto do <code>TextView</code>
 é alterado através do <code>TextWatcher.afterTextChanged(android.text.Editable)</code>. Por exemplo, se o usuário concebe um "de" com swipe e
 o <code>Editable</code> com o "de" é alterado, qualquer outro input fará com que o "de" seja repetido. No caso de um espaço,
 o input que chegará será um "de ", ou seja, no final das contas o Editable ficará com "dede ".<br>
 Isto ocorre porque o teclado com swipe coloca um Span (ComposingText) que engloba o texto concebido com o swipe no Editable,
 mas este Span é excluído automaticamente quando o <code>Editable.replace(int, int, CharSequence)</code> é chamado
 (que é uma operação liberada para ser feita no <code>TextWatcher.afterTextChanged(android.text.Editable)</code>). O problema é que o
 teclado com swipe assume que o Span que ele adicionou vai estar lá, então ele manda substituir o texto englobado
 por ele pelo texto da palavra concebida somado ao novo input (como no exemplo, ele manda substituir o "de" por "de ").
 Mas como o Span não está mais lá, o <code>BaseInputConnection</code> assume que o texto deve ser inserido onde o cursor
 está, ou seja, ao invés de substituir o texto, ele apenas insere ele (fazendo com que o "de" se torne "dede ").<br> 
 <br>
 O contorno é englobar o <code>TextWatcher</code> com um que verifica se o texto possui o Span de comspoição antes de ser
 alterado e em caso afirmativo, ele chama o <code>InputMethodManager.restartInput(android.view.View)</code> para sinalizar ao teclado
 com swipe que ele não deve mais inserir o texto da palavra concebida.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>context</code> - contexto.</dd>
<dd><code>textView</code> - TextView onde o TextWatcher está inserido.</dd>
<dd><code>textWatcher</code> - TextWatcher que será corrigido.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>um TextWatcher que contorna o bug.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug163954-java.lang.IllegalArgumentException-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug163954</h4>
<pre>public static&nbsp;boolean&nbsp;applyWorkaroundForBug163954(java.lang.IllegalArgumentException&nbsp;e)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=163954 <br>
 O SwipeRefreshLayout se perde em um evento de click misterioso (sem ação do usuário).
 A correção verifica um <code>IllegalArgumentException</code> ocorrido durante o <code>SwipeRefreshLayout#onTouchEvent(MotionEvent)</code> e,
 se for o bug, simplesmente ignora-o. Não há nenhum impacto ao usuário.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>e</code> - exceção ocorrida durante o onTouchEvent.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug52962-android.content.Context-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyWorkaroundForBug52962</h4>
<pre>public static&nbsp;boolean&nbsp;applyWorkaroundForBug52962(android.content.Context&nbsp;context)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=52962 <br>
 O BuildConfig.DEBUG de bibliotecas fica sempre como <code>false</code>, mesmo que a aplicação tenha sido buildada em modo DEBUG.<br>
 O contorno obtém o BuildConfig.DEBUG da aplicação através de reflexão.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>context</code> - contexto.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> se a aplicação foi construída em modo DEBUG e <code>false</code> caso contrário.</dd>
</dl>
</li>
</ul>
<a name="applyWorkaroundForBug69711-DrawerLayout-ActionBarDrawerToggle-android.view.View-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>applyWorkaroundForBug69711</h4>
<pre>public static&nbsp;void&nbsp;applyWorkaroundForBug69711(DrawerLayout&nbsp;drawerLayout,
                                              ActionBarDrawerToggle&nbsp;actionBarToggle,
                                              android.view.View&nbsp;drawerView)</pre>
<div class="block">Contorno para o bug descrito em: https://code.google.com/p/android/issues/detail?id=69711<br>
 O <code>drawerLayout</code> não chama o listener (<code>actionBarToggle</code>) quando é aberto antes de sofrer layout.
 O contorno faz com que o listener seja chamado caso o <code>drawerLayout</code> ainda não tenha sofrido layout.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>drawerLayout</code> - o <code>DrawerLayout</code>.</dd>
<dd><code>actionBarToggle</code> - o <code>ActionBarDrawerToggle</code>.</dd>
<dd><code>drawerView</code> - a View utilizada no drawer.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../android/support/v4/app/EnhancedDialogFragment.html" title="class in android.support.v4.app"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?android/support/v4/app/AndroidBugsUtils.html" target="_top">Frames</a></li>
<li><a href="AndroidBugsUtils.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
